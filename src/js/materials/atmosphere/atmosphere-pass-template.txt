StarrySky.Materials.Atmosphere.atmosphereShader = {
  uniforms: function(isSunShader = false, isMoonShader = false, isMeteringShader = false,
  auroraEnabled = false, cloudsEnabled = false){
    let uniforms = {
      uTime: {value: 0.0},
      localSiderealTime: {value: 0.0},
      latitude: {value: 0.0},
      sunPosition: {value: new THREE.Vector3()},
      moonPosition: {value: new THREE.Vector3()},
      moonLightColor: {value: new THREE.Vector3()},
      mieInscatteringSum: {value: new THREE.DataTexture3D()},
      rayleighInscatteringSum: {value: new THREE.DataTexture3D()},
      transmittance: {value: null},
      sunHorizonFade: {value: 1.0},
      moonHorizonFade: {value: 1.0},
      scatteringSunIntensity: {value: 20.0},
      scatteringMoonIntensity: {value: 1.4},
      blueNoiseTexture: {value: null},
      cameraHeight: {value: 0.0}
    }

    if(cloudsEnabled && !isMeteringShader){
      uniforms.cloudLUTs = {value: new THREE.DataTexture3D()};
      uniforms.ambientLightPY = {value: new THREE.Vector3(0, 181, 226)};
      uniforms.cloudCoverage = {value: 0.5};
      uniforms.cloudVelocity = {value: new THREE.Vector2(0.0, 0.0)};
      uniforms.cloudStartHeight = {value: 1000.0};
      uniforms.cloudEndHeight = {value: 2500.0};
      uniforms.numberOfCloudMarchSteps = {value: 64.0};
      uniforms.cloudFadeOutStartPercent = {value: 0.9};
      uniforms.cloudFadeInEndPercent = {value: 0.05};
      uniforms.cloudTime = {value: 0.0};
      uniforms.cloudCutoffDistance = {value: 40000.0};
    }

    if(auroraEnabled){
      uniforms.auroraSampler = {value: null};

      uniforms.nitrogenColor = {value: new THREE.Vector3()};
      uniforms.nitrogenCutOff = {value: null};
      uniforms.nitrogenIntensity = {value: null};

      uniforms.molecularOxygenColor = {value: new THREE.Vector3()};
      uniforms.molecularOxygenCutOff = {value: null};
      uniforms.molecularOxygenIntensity = {value: null};

      uniforms.atomicOxygenColor = {value: new THREE.Vector3()};
      uniforms.atomicOxygenCutOff = {value: null};
      uniforms.atomicOxygenIntensity = {value: null};

      uniforms.numberOfAuroraRaymarchingSteps = {value: null};
      uniforms.auroraCutoffDistance = {value: null};
    }

    //Pass our specific uniforms in here.
    if(isSunShader){
      uniforms.sunAngularDiameterCos = {value: 1.0};
      uniforms.radiusOfSunPlane = {value: 1.0};
      uniforms.moonRadius = {value: 1.0};
      uniforms.worldMatrix = {value: new THREE.Matrix4()};
      uniforms.solarEclipseMap = {value: null};
      uniforms.moonDiffuseMap = {value: null};
      uniforms.cameraPosition = {value: new THREE.Vector3()};
    }
    else if(isMoonShader){
      uniforms.moonExposure = {value: 1.0};
      uniforms.moonAngularDiameterCos = {value: 1.0};
      uniforms.sunRadius = {value: 1.0};
      uniforms.radiusOfMoonPlane = {value: 1.0};
      uniforms.distanceToEarthsShadowSquared = {value: 1.0};
      uniforms.oneOverNormalizedLunarDiameter = {value: 1.0};
      uniforms.worldMatrix = {value: new THREE.Matrix4()};
      uniforms.sunLightDirection = {value: new THREE.Vector3()};
      uniforms.earthsShadowPosition = {value: new THREE.Vector3()};
      uniforms.moonDiffuseMap = {value: null};
      uniforms.moonNormalMap = {value: null};
      uniforms.moonRoughnessMap = {value: null};
      uniforms.moonApertureSizeMap = {value: null};
      uniforms.moonApertureOrientationMap = {value: null};
      uniforms.cameraPosition = {value: new THREE.Vector3()};
    }

    if(!isSunShader){
      uniforms.starHashCubemap = {value: null};
      uniforms.dimStarData = {value: null};
      uniforms.medStarData = {value: null};
      uniforms.brightStarData = {value: null};
      uniforms.starColorMap = {value: null};

      uniforms.mercuryPosition = {value: new THREE.Vector3()};
      uniforms.venusPosition = {value: new THREE.Vector3()};
      uniforms.marsPosition = {value: new THREE.Vector3()};
      uniforms.jupiterPosition = {value: new THREE.Vector3()};
      uniforms.saturnPosition = {value: new THREE.Vector3()};

      uniforms.mercuryBrightness = {value: 0.0};
      uniforms.venusBrightness = {value: 0.0};
      uniforms.marsBrightness = {value: 0.0};
      uniforms.jupiterBrightness = {value: 0.0};
      uniforms.saturnBrightness = {value: 0.0};
    }

    if(!isSunShader){
      uniforms.starsExposure = {value: -4.0};
    }

    if(isMeteringShader){
      uniforms.sunLuminosity = {value: 20.0};
      uniforms.moonLuminosity = {value: 1.4};
    }

    return uniforms;
  },
  vertexShader: [
    {vertex_glsl}
  ].join('\n'),
  fragmentShader: function(mieG, textureWidth, textureHeight, packingWidth,
  packingHeight, atmosphereFunctions, sunCode = false, moonCode = false,
  meteringCode = false, auroraEnabled = false, cloudsEnabled = false){
    let originalGLSL = [
      {fragment_glsl}
    ];

    let mieGSquared = mieG * mieG;
    let miePhaseFunctionCoefficient = (1.5 * (1.0 - mieGSquared) / (2.0 + mieGSquared));
    let textureDepth = packingWidth * packingHeight;

    let updatedLines = [];
    for(let i = 0, numLines = originalGLSL.length; i < numLines; ++i){
      let updatedGLSL = originalGLSL[i].replace(/\$atmosphericFunctions/g, atmosphereFunctions);
      updatedGLSL = updatedGLSL.replace(/\$mieG/g, mieG.toFixed(16));
      updatedGLSL = updatedGLSL.replace(/\$mieGSquared/g, mieGSquared.toFixed(16));
      updatedGLSL = updatedGLSL.replace(/\$miePhaseFunctionCoefficient/g, miePhaseFunctionCoefficient.toFixed(16));

      //Texture constants
      updatedGLSL = updatedGLSL.replace(/\$textureWidth/g, textureWidth.toFixed(1));
      updatedGLSL = updatedGLSL.replace(/\$textureHeight/g, textureHeight.toFixed(1));
      updatedGLSL = updatedGLSL.replace(/\$packingWidth/g, packingWidth.toFixed(1));
      updatedGLSL = updatedGLSL.replace(/\$packingHeight/g, packingHeight.toFixed(1));
      updatedGLSL = updatedGLSL.replace(/\$textureDepth/g, textureDepth.toFixed(1));

      //Additional injected code for sun and moon
      if(moonCode !== false){
        updatedGLSL = updatedGLSL.replace(/\$isMoonPass/g, '1');
        updatedGLSL = updatedGLSL.replace(/\$isSunPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_sun_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$draw_moon_pass/g, moonCode);
        updatedGLSL = updatedGLSL.replace(/\$isMeteringPass/g, '0');
      }
      else if(sunCode !== false){
        updatedGLSL = updatedGLSL.replace(/\$isMoonPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_moon_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$isSunPass/g, '1');
        updatedGLSL = updatedGLSL.replace(/\$draw_sun_pass/g, sunCode);
        updatedGLSL = updatedGLSL.replace(/\$isMeteringPass/g, '0');
      }
      else if(meteringCode !== false){
        updatedGLSL = updatedGLSL.replace(/\$isMoonPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_moon_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$isSunPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_sun_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$isMeteringPass/g, '1');
      }
      else{
        updatedGLSL = updatedGLSL.replace(/\$isMoonPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_moon_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$isSunPass/g, '0');
        updatedGLSL = updatedGLSL.replace(/\$draw_sun_pass/g, '');
        updatedGLSL = updatedGLSL.replace(/\$isMeteringPass/g, '0');
      }

      if(auroraEnabled){
        updatedGLSL = updatedGLSL.replace(/\$auroraEnabled/g, '1');
      }
      else{
        updatedGLSL = updatedGLSL.replace(/\$auroraEnabled/g, '0');
      }

      if(cloudsEnabled){
        updatedGLSL = updatedGLSL.replace(/\$cloudsEnabled/g, '1');
      }
      else{
        updatedGLSL = updatedGLSL.replace(/\$cloudsEnabled/g, '0');
      }

      updatedLines.push(updatedGLSL);
    }

    return updatedLines.join('\n');
  }
}
